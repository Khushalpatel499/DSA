//algorithm
1. check position if less than 1 then return head;
2. traversal the list less than 1 to the position and check if curr pointer is null then return head;
3. if pos is 1 then insert at front by create a node and put newNode->next to head pointer.
4. then create newNode and put curr->next to the newNode->next and curr->next =newNode;

// 1. if pos<1 retun head;
   2. if pos ==1 then  newNode->next=head;
                      return newNode;
  3.  curr=head;
  4. for int i=1;i<pos-1 && curr!=nullptr;i++
  5.  curr=curr->next;
  6. curr == nullptr return head;
  7. newNode ->next = curr->next;
  8.  curr->next =newNode;
  9. return head;


// Implementation

#include<iostream>
using namespace std;
class Node{
        public:
        int data;
        Node* next;
        Node(int new_data){
            this->data =new_data;
            this->next =nullptr;

         }
};

void traversal(Node* head){
     Node* curr=head;
        while(curr!=nullptr){
               cout<<curr->data<<" ";
               curr=curr->next;
}
 cout<<endl;

}
Node* insertAtSpecificLoc(Node* head,int pos,int key){
          if(pos<1) return head;
          if(pos==1){
           Node* newNode = new Node(key);
           newNode->next=head;
           return newNode;
          }
          Node* curr=head;
        for(inti=1;i<pos-1&&curr!=nullptr;i++){
                 curr=curr->next;
               }
        if(curr==nullptr){
               return head;
}
        Node* newNode = new Node(key);
         newNode->next = curr->next;
          curr->next= newNode;
       return head;  
}
int main(){
   Node* newNode = new Node(10);
   head->next = new Node(20);
   head->next->next = new Node(30);
   head->next->next->next = new Node(40);
   traversal(head);
   int pos=3;
   int key=50;
   head=insertAtSpecificLoc(head,pos,key);
   traversal(head);
   return 0;
}