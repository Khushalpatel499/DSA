#Algorithm:

1. start from the head of linked list.
2. loop from the list while loop become null and check each node data
    a. if the node data match to the target data return true
    b. otherwise move to the next node.
3. return false.

// 1. let curr=head
      while(curr!=null){
   2. if( curr->data==target_data){
   3.      return true
           curr=curr->next
   4. }
   5. }
   6. return false;


// Iterative Approach:

#include <iostream>
using namespace std;

class Node{
    public:
       int data;
       Node* next;
       
       Node(int new_data){
           this->data=new_data;
           this->next=nullptr;
       }
};

bool searchKey(Node* head,int key){
    Node* curr = head;
    while(curr!=nullptr){
        if(curr->data==key){
            return true;
        }
        curr=curr->next;
    }
    return false;
}



int main()
{
      Node* head = new Node(10);
      head->next = new Node(20);
      head->next->next= new Node(30);
      head->next->next->next = new Node(40);
      
      int key=50;
      
      if(searchKey(head,key)){
          cout<<"Yes";
      }
      else{
          cout<<"No";
      }

    return 0;
}


//Recursive Approach:

#include<iostream>
using namespace std;
class Node{
    public:
    int data;
    Node* next;
    
    Node(int new_data){
        this->data=new_data;
        this->next=nullptr;
    }
};

bool  serachKey(Node* head,int key){
    Node* curr=head;
    if(curr ==nullptr){
        return false;
    }
    if(curr->data==key){
        return true;
    }
    return serachKey(curr->next,key);
    
}
int main(){
       Node* head = new Node(10);
       head->next = new Node(20);
       head->next->next = new Node(30);
       head->next->next = new Node(40);
       
       int key =50;
       if(serachKey(head,key)){
           cout<<"Yes";
       }else{
           cout<<"No";
       }
       
    return 0;
}